import json
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from bot.plugins.dev import shell_exec
from bot import app
from pyrogram import filters
from info import COMMAND_HANDLER
from bot.utils.decorator import capture_err

DATA = {}


@capture_err
@app.on_message(filters.command(["extractsub"], COMMAND_HANDLER))
async def extractsub(_, msg):
    link = msg.text.split()[1]
    pesan = await msg.reply("Processing...")
    res = (await shell_exec(
        f"ffprobe -loglevel 0 -print_format json -show_format -show_streams {link}"
    ))[0]
    details = json.loads(res)
    buttons = []
    DATA[f"{msg.chat.id}-{msg.id}"] = {}
    for stream in details["streams"]:
        mapping = stream['index']
        stream_name = stream['codec_name']
        stream_type = stream['codec_type']
        try:
            lang = stream["tags"]["language"]
        except:
            lang = mapping
        DATA[f"{msg.chat.id}-{msg.id}"][int(mapping)] = {
            "map": mapping,
            "name": stream_name,
            "type": stream_type,
            "lang": lang,
            "link": link
        }
        buttons.append([
            InlineKeyboardButton(
                text=f"{stream_type.upper()} - {str(lang).upper()}",
                callback_data=
                f"{stream_type}_{mapping}_{msg.chat.id}_{pesan.id}")
        ])

    buttons.append([
        InlineKeyboardButton(
            text="Ga Jadi",
            callback_data=f"cancel_{mapping}_{msg.chat.id}_{pesan.id}")
    ])
    await pesan.edit_text("**Select the Stream to be Extracted...**",
                          reply_markup=InlineKeyboardMarkup(buttons))


async def extract_subtitle(message, data):
    await message.edit("Extracting Stream from file")
    link = data['link']
    out_loc = "MissKatySub.srt"
    out = (await
           shell_exec(f"ffmpeg -i {link} -map 0:{data['map']} {out_loc}"))[0]
    await app.send_document(
        chat_id=message.chat.id,
        document=out_loc,
        caption="Generated by @MissKatyRoBot",
    )


@app.on_callback_query(filters.regex('^subtitle_'))
async def sub_callback(_, query):
    await query.answer()
    try:
        stream_type, mapping, keyword = query.data.split('_')
        data = DATA[keyword][int(mapping)]
        await extract_subtitle(query.message, data)
    except:
        await query.message.edit_text("**Details Not Found**")